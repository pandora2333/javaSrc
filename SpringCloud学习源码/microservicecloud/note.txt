1.微服务是什么？
	就目前而言，对于微服务业界并没有一个统一的，标准的定义
	但通常而言，微服务框架是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分一组小的微服务，每个服务运行在其独立的自己的进程中，
服务之间相互协调， 相互配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通，通常是基于HTTP的RESTful API。每个服务都围绕着具体业务进行构建，并且
能够被独立部署到生产环境，类生产环境等。另外，应尽量避免统一的，集中式的服务管理机制，对于具体的一个服务而言，应根据业务上下文，选择合适的语言，工具对其进行构建，可以有一个
非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。
2.微服务的优缺点？
	优点：
		每个服务足够的小，代码容易理解这样能聚集一个指定的业务功能或业务需求
		开发简单，开发效率高，一个服务可能就是专一的只干一件事
		微服务能够被小团队单独开发，这个小团队是由2-5人组成
		微服务是松耦合的，具有功能意义的服务，无论是在开发阶段或部署阶段都是独立的
		微服务能使用不同的语言开发
		易于和第三方集成，微服务允许容易灵活的方式集成自动部署，通过持续集成工具，如Jenkins，Hudson，bamboo
		微服务易于被一个开发人员所理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值
		微服务允许你利用最新的融合技术
		微服务只是业务逻辑的代码，不会和HTML,CSS或其它界面组件混合
		每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库
	缺点：
		开发人员要处理分布式系统的复杂性
		多服务运维难度，随着服务的增加，运维的压力也在增大
		系统的部署依赖
		服务间通信的成本
		数据一致性
		系统集成测试
		性能监控
		...
3.微服务技术栈有哪些？
	微服务条目		落地技术
	
	服务开发			SpringBoot，Spring，SpringMVC
	服务配置和管理		Netflix的Archaius，阿里的Diamond
	服务注册与发现		Eureka，Consul，Zookeeper等
	服务调用			Rest，RPC，gRPC
	服务熔断器		Hystrix，Envoy等
	负载均衡			Ribbon，Niginx等
	服务接口调用		Feign等
	消息队列			Kafka，RabbitMQ,ActiveMQ等
	服务配置中心管理	SpringCloudConfig，Chef等
	服务路由（API网关）Zuul等
	服务监控			Zabbix，Nagios，Metrics，Spectator等
	全链路追踪		Zipkin，Brave，Dapper等
	服务部署			Docker，OpenStack，Kubernetes等
	数据流操作开发包	SpringCloud Stream（封装与Redis，Rabbit，Kafka等发送接收消息）
	事件消息总线		SpringCloud Bus
	...
4.SpringCloud与SpringBoot是什么关系？
	SpringBoot专注于快速方便的开发单个个体的微服务
	SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选，分布式会话等等
	SpringBoot可以离开SpringBootCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系
	SpringBoot专注于快速，方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架
5.Dubbo vs SpringCloud
					Dubbo		SpringCloud
	服务注册中心   		Zookeeper	SpringCloud Eureka
	服务调用方式		RPC			REST
	服务监控			Doubbo-monitor	SpringBoot Admin
	断路器			不完善		Hystrix
	服务网关			无			Zuul
	分布式配置		无			SpringCloud Config、
	服务跟踪			无			Sleuth
	消息总线			无			Bus
	数据流			无			Stream
	批量任务			无			Task
	...
	最大区别：SpringCloud抛弃了Dubbo的rpc通信，采用的是基于HTTP的REST方式
	严格来说，这两种方式各有优劣。虽然一定程度上来讲，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一个配置文件，不存在代码级别的强依赖，这是强调快速演化的微服务环境下，显得更加的合适
	品牌机和组装机的区别：Spring与其它SpringBoot，SpringData，SpringBatch等Spring项目完美融合，而对于Dubbo，它的各个环节的选择自由度高
6.SpringCloud学习网址：
	https://springcloud.cc/spring-cloud-netflix.html
	https://springcloud.cc/spring-cloud-dalston.html
	SpringCloud中国社区/SpringCloud中文网
7.SpringCloud基础实现：
	服务注册与发现：Eureka
	服务消费者：rest+Ribbon
	服务消费者：Feign
	断路器：Hystrix
	断路器监控：Hystrix Dashboard
	路由网关：Zuul
	分布式配置中心：SpringCloud Config
	消息总线：Spring Cloud Bus
	服务链路追踪：SpringCloud Sleuth
	...
8.Eureka的自我保护：
	在自我保护模式中，Eureka会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数量恢复到阀值以上时，该Eureka Server节点就会自动退出自我保护模式。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。
	综上，自我保护模式是一种应对网络异常的安全保护模式。它的架构哲学是宁可保留所有的微服务（健康的微服务和不健康的微服务都会保留），，也不盲目注销任何可能健康的微服务。使用自我保护模式，可以让Eureka集群更加的强健
	在SpringCloud中，可以使用eureka.server.enable-self-preservation=false禁用自我保护模式
9.Eureka自我保护触发的原因：
	默认情况下，如果EurekaServer在一定的时间内没有接收到某个微服务实例的心跳，EurekaServer就会注销实例（默认90s），但是当网络分区发生故障时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了-因为微服务本身其实是健康的，此时本不应该注销这个微服务。
	Eureka通过“自我保护模式”，来解决这个问题-当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护状态。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。
	当网络故障恢复后，该EurekaServer节点会自动退出自我保护模式
10.补充简绍CAP的三进二理论：RDBMS（传统型数据库：MySQL，Oracle等）是属于CA,而MongoDB，HBase，Redis是属于CP	
11.作为服务注册中心，Eureka比Zookeeper好在哪里？
	1.Zookeeper保证CP，而当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性要求高于一致性。但是zk会出现这样的一种情况，当master节点因为网络故障与其他的节点失去联系时，剩余节点会重新进行leader选举。
	问题在于，选举leader时间太长，30-120s，且选举期间整个zk集群都是不可用的，这就会导致在选举期间注册的服务瘫痪。在云部署的环境下，因为网络问题使得zk集群失去master节点是较大该率发生的事，虽然服务能够恢复，但是漫长的选举时间导致的注册服务长期不可用是不能容忍的。
	2.Eureka保证AP，保证高可用性。Eureka的各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台Eureka还在，就能保证注册服务可用。只不过查到的信息可能不是最新的。
	除此之外，Eureka还有一种自我保护机制，如果在15分钟以内，超过85%的节点都没有正常的心跳。那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
		1：Eureka不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务
		2：Eureka能够接受新服务的注册和查询请求，但是不会被同步到其他的节点上
		3：当网络稳定时，当前实例新的注册信息会被同步到其它节点上
	因此，Eureka可以很好的应对网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使得整个注册服务瘫痪。
	Eureka与Ribbon整合之后，客户端调用可以不关心微服务的地址和端口
12.SpringCloud Ribbon是基于Netflix Ribbon实现下的一套客户端，负载均衡的工具
13.负载均衡分为：
	集中式LB：即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发到服务的提供方
	进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获取有哪些可用的地址可用，然后自己在从这些地址中选择一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务器提供方提供的地址
14.Ribbon在默认负载均衡算法下，工作时分为两步：
	1.先选择EurekaServer，它优先选着在同一个区域内负载较少的server！
	2.再根据用户指定的策略，比如轮询，随机，根据时间加权等
15.Ribbon自带的负载均衡算法：
	RoundRobinRule :轮询
	RandomRule：随机
	AvailabilityFilteringRule：会先过滤由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阀值的服务，然后剩下的按照轮询
	WeightedResponseTimeRule：根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足，按照轮询策略，等统计信息足够，会切换成该策略
	RetryRule：先按照轮询策略获取服务，如果获取服务失败，则在指定的次数内会进行重试，默认是三次，完全失败后，就不再访问了
	BestAvailableRule：会先过滤由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量小一点的服务
	ZoneAvailableRule：默认规则，符合判断server所在区域的性能和server的可用性选择服务器
16.Feign：
	Feign是一个声明式webservice的客户端，使用Feign能让编写web service客户端变得更加简单，它的使用方法是定义一个接口，然后在上面加注解，同时也支持JAX-RS标准的注解。Feign也可以支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装
，使其支持了Spring MVC的标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡
	开发中，由于对服务依赖的调用可能不止一个，往往一个接口会被多处调用，所以通常都会针对每一个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上进一步封装，由他来帮助我们定义和实现依赖的服务接口的定义。
在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它，即可完成对服务提供方的接口绑定，简化了使用Springcloud Ribbon时，自动封装服务调用客户端的开发量
	Feign集成了Ribbon：
		利用Ribbon维护了服务列表信息，并且通过轮询实现了客服端的负载均衡，而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单实现了服务调用
	总结：
		Feign通过接口的方法调用了Rest服务（之前是Ribbon+RestTemplate），该请求发送给Eureka服务器（http://服务名/路径），通过feign直接找到服务接口，由于在进行服务调用的时候融合了Ribbon技术，所以也支持负载均衡作用
17.服务雪崩（分布式系统面临的问题）：
	多个微服务之间调用的时候，假设微服务a调用了微服务b和微服务c，微服务b和c又调用了其它微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务a的调用就会越来越占系统资源，进而引起系统崩溃，所谓的“雪崩效应”
对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几分钟之内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其它系统资源紧张，导致在整个系统发生更多的级联故障，这些都是需要对故障和延迟进行隔离和管理的，以便单个依赖关系失败，不会取消整个应用或系统
18.Hystrix：
	是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多的依赖不可避免的会调用失败，比如超时，异常等。Hystrix能够保证在一个依赖出现问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性
	“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会长时间的，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩
	Hystrix能干什么：
		服务降级
		服务熔断
		服务限流
		接近实时的监控...
19.	服务熔断：
	熔断机制是应对雪崩效应的一种微服务链路保护机制
	当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级（服务降级是在客户端实现的，与服务端无关），进而熔断该节点的服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定的阀值，缺省是5s内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand
20.Hystrix Dashboard：
	除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以报表和图形的形式展示给用户，包括每秒执行多少请求，多少成功，多少失败等。Spring Cloud提供了Hystrix Dashboard的整合，对监控内容转化为可视化界面。
	其中，http://localhost:9001/hystrix界面下对http://localhost:8001/hystrix.stream的监控的两个参数：
		delay：用于控制服务器上轮询监控信息的延迟时间，默认为2000ms，可以通过配置该属性降低客户端的网络和cpu的消耗
		title：对应了头部标题hystrix.stream之后的内容，默认会使用监控实例的URL，可以配置该信息来展示更合适的标题
	实心圆：
		颜色代表实例的健康程度，它的健康度：绿《黄《橙《红
		大小会根据实例的请求流量发生变化，流量越大，实心圆越大，所以通过该实心圆的展示就可以在大量的实例中快速发现故障的实例和高压力的实例
	曲线：用来记录2分钟内流量的相对变化，可以通过他观察到流量的上升和下降趋势
21.Zuul：
	Zuul包含了对请求的代理，路由，过滤三大功能
	其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤则负责对请求的处理过程进行干涉，是实现请求校验，服务聚合等功能的基础，Zuul和Eureka进行整合后，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其它微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得
	注意：Zuul服务器最终还是会注册到	Eureka
22.分布式配置：
	SpringCloud Config为微服务架构中的微服务提供了集中化的外部配置支持，配置服务为各个不同的微服务应用的所有环境提供了一个中心化的外部配置
	SpringCloudConfig提供了服务端和客户端两部分
	服务端也称分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口
	客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容并在启动的时候从配置中心获取和加载配置信息。
	配置服务器默认采用git来存储信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容
	总结：
		分布式配置能干什么：
			集中管理配置文件
			不同环境不同配置，动态的配置更新，分环境部署，比如dev/test/beta/release
			运行期间动态的调整配置，不再需要在每个服务部署的机器上编写相同的文件，服务会向配置中心拉取自己的配置文件
			当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置
			将配置信息以rest形式暴露
23.SpringCloud的资源配置文件：
	application.yml是用户级的资源配置项
	bootstrap.yml是系统级的，优先级更高
	Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载资源配置文件并解析属性。这两个上下文共享一个从外部获取的Environment
	Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。Bootstrap Context和Application Context有着不同的约定
	所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离
24.Spring Cloud微服务应用开发架构：
	整套开发技术栈以SpringCloud为主，单个微服务模块以SpringMVC+SpringBoot/Spring+MyBatis组合进行开发
	前端开发：页面H5+thymeleaf/样式CSS3+Bootstrap/前端框架JQuery+Node|Vue等
	负载层：前端访问通过Http或Https协议到达服务端的LB，可以是F5等硬件做负载均衡，还可以自行部署LVS+Keepalived等（前期量小，可以直接使用Nginx（反向代理+动静分离+负载均衡））
	网关层：请求通过LB后，会到达整个微服务体系的网关层Zuul，内嵌Ribbon做客户端负载均衡，Hystrix做熔断降级等
	服务注册：采用Eureka来做服务治理，Zuul会从Eureka集群获取以发布的微服务访问地址
	docker容器：所有的微服务模块都部署在Docker容器里面，而且前后端的服务完全分开，各自独立部署后前端微服务调用后端微服务，后端微服务之间会相互调用
	服务调用：微服务模块之间调用都采用标准的Http/Https+REST+JSON的方式，调用技术采用Feign+HttpClient+Ribbon+Hystrix
	统一的配置：每个微服务模块会跟Eureka集群，配置中心等进行交互
	第三方框架：每个微服务模块根据实现的需要，通常还需要使用一些第三方框架，比如常见的有：缓存服务器（Redis），图片服务（FastDFS），搜索服务（ElasticSearch）安全服务（Shiro）等进行整合
	数据库整合：可以根据微服务模块进行划分，统一访问公共库或者自己单独的类，可以单独使用MySQL集群或者分库分表MyCAT等